<div><h2>peek, pop and IPersistentStack</h2><h3>Why bother writing this?</h3><p class="blog-post">There was a question floating on the twitter TL yesterday asking why<a href="link todo"> peek</a> and <a href="link todo">pop</a> behave differently on lists and vectors. As I never saw those two functions before, that got me curious to look up stuff and write this post up.</p><h3>tl;dr:</h3><ul class="blog-post"><li>They are actually interface methods of <a href="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/IPersistentStack.java">IPersistentStack</a></li><li>peek returns the &apos;last&apos; value that was conj&apos;d immediately before</li><li>pop returns the coll with the value conj&apos;d immediately before removed</li><li>Clojure <a href="https://github.com/clojure/clojure/blob/f572a60262852af68cdb561784a517143a5847cf/src/jvm/clojure/lang/PersistentList.java">lists</a> and <a href="https://github.com/clojure/clojure/blob/ebfdbca535b81808b3ddc369d4a4e98b8f1524c7/src/jvm/clojure/lang/APersistentVector.java">vectors</a> implement this IPersistentStack differently, thus the difference</li></ul><h3>So, what is a <a href="https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29">stack?</a></h3>In general they are LIFO abstract datatypes that supports these 3 ops:<ul class="blog-post"><li>push - add an element</li><li>pop - remove the element that was last added</li><li>peek - return the element that was last added without popping(optional)</li></ul><h3>Immutable stack in Clojure?</h3>However conventional stack ops are mutations that Clojurians avoid. The 3 ops would blend much nicer with Clojure if they were functional like this:<ul class="blog-post"><li>push - takes a coll and an element, returns the coll with element added (conj)</li><li>pop - takes a coll and returns the coll with the element that was &apos;added&apos; &apos;immediately before&apos;</li><li>peek - take a coll and returns the element that was &apos;added&apos; &apos;immediately before&apos;</li></ul><strong>Note: </strong>I am putting &apos;added&apos; and &apos;immediately before&apos; in quotes in order to not confuse the terms relative to time. The context would instead be in terms of function applications.<h3>conj</h3><div>For lists conj returns another list with the element added to the head</div><code class="boxed"><div>;; conj to a list</div><div>(conj &apos;(1 2 3 4) 5) =&gt; (5 1 2 3 4)</div></code><div>For vectors conj returns another vector with the element added to the tail</div><code class="boxed"><div>;; conj to a vector</div><div>(conj [1 2 3 4] 5) =&gt; [1 2 3 4 5]</div></code><h3>peek</h3><div>Regardless of treating a list or a vector, the &apos;last&apos; element that was conj&apos;d was 5, so peeking will yield 5.</div><code class="boxed"><div>(-&gt; [1 2 3 4] (conj 5) peek)</div><div>=&gt;5</div><div>(-&gt; &apos;(1 2 3 4) (conj 5) peek)</div><div>=&gt;5</div></code><h3>pop</h3><div>Regardless of treating a list or a vector, the &apos;last&apos; element that was conj&apos;d was 5, so popping will yield the collection with 5 removed</div><code class="boxed"><div>(-&gt; [1 2 3 4] (conj 5) pop)</div><div>=&gt; [1 2 3 4]</div><div>(-&gt; &apos;(1 2 3 4) (conj 5) peek)</div><div>=&gt; (1 2 3 4)</div></code><h3>Tips: want to get the last element from a vector? peek!</h3><p>Because last (the function) relies on the sequence abstraction it has to scan through the entire vector to reach the last element.</p><p>On the otherhand peek is a different abstraction that happens to return the last element of the vector.</p></div>